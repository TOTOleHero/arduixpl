/*  ArduixPL - xPL for arduino  Copyright (c) 2012 Mathieu GRENET.  All right reserved.  This file is part of ArduixPL.    ArduixPL is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    ArduixPL is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with ArduixPL.  If not, see <http://www.gnu.org/licenses/>.	  Modified Oct 31, 2012 by Mathieu GRENET*/#ifndef XPL_SENSOR_H#define XPL_SENSOR_H#include "utility/xPL_Schema.h"#include "utility/xPL_String.h"#include "utility/xPL_Numeric.h"//#include "utility/xPL_Message.h"class xPL_Sensor:public xPL_Node {public:	virtual bool targeted(xPL_Message& msg);	virtual void msgAddCurrent(xPL_Message& msg)=0;	virtual bool parseMessage(xPL_Message& msg) {		if (!targeted(msg)) return false;		if ( msg.isTypeCommand(S(cmnd),S(request)) )		{			xPL_Message msgOut(S(stat),S(sensor),S(basic));
			msgOut.addKey(S(device),id());
			msgOut.addKey(S(type),className());

			if (msg.key_request()==S(current)) msgAddCurrent(msgOut);
			if (msg.key_request()==S(name)) msgOut.addKey(S(name),id());
			xPL.sendMessage(msg);		}		return false;	}};class xPL_SensorTemp:public xPL_Sensor {private:	mutable xPL_Float _publicTemp;	xPL_Float _temp;	xPL_Float  _highestTemp;	xPL_Float  _lowestTemp;	float _threshold;protected:	virtual const prog_char* className() const { return S(temp); }	virtual void msgAddCurrent(xPL_Message& msg)	{		msg.addKey(S(current),&_temp);		msg.addKey(S(current),&_lowestTemp);		msg.addKey(S(current),&_highestTemp);		msg.addKey(S(units),PSTR("c"));	}public:	void setTemp(float t) {		_temp=t;		if (_highestTemp<t) _highestTemp=t;		if (_lowestTemp>t) _lowestTemp=t;		if (abs(_temp-_publicTemp)>=_threshold)		{			xPL_Message msg(S(trig),S(sensor),S(basic));
			msg.addKey(S(device),id());
			msg.addKey(S(type),className());
			msgAddCurrent(msg);			xPL.sendMessage(msg);		}	}};#include <OneWire.h>#include <DallasTemperature.h>class xPL_SensorTempOneWire:public xPL_SensorTemp {DeviceAddress _addr;public:	static OneWire oneWire;	static DallasTemperature sensors;	xPL_SensorTempOneWire(DeviceAddress addr) { for (byte i=0;i<8;i++) _addr[i] = addr[i]; }	virtual bool loop()	{		 setTemp(sensors.getTempC(_addr));		 return false;	}};class xPL_SchemaSensor:public xPL_Schema {public:	virtual const prog_char* className() const { return S(sensor); }	xPL_Sensor* add(xPL_Sensor* node) { return (xPL_Sensor*)addChild(node); }	virtual bool parseMessage(xPL_Message& msg) {		if (!targeted(msg)) return false;		return true;	};};extern xPL_SchemaSensor xplSensor;#endif