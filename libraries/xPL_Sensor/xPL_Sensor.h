/*  ArduixPL - xPL for arduino  Copyright (c) 2012 Mathieu GRENET.  All right reserved.  This file is part of ArduixPL.    ArduixPL is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    ArduixPL is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with ArduixPL.  If not, see <http://www.gnu.org/licenses/>.	  Modified Dec 23, 2012 by Mathieu GRENET*/#ifndef XPL_SENSOR_H#define XPL_SENSOR_H#include "utility/xPL_Schema.h"#include "utility/VString.h"#include "utility/xPL_Numeric.h"//#include "utility/xPL_Message.h"class xPL_Sensor:public xPL_Node {protected:	VString _id;public:	xPL_Sensor(const VString& name):_id(name) {  }	virtual const __FlashStringHelper* className() const { return S(sensor); }		virtual const VString id() const { return _id; }	void setId(const VString& id) { _id=id; }	virtual bool targeted(xPL_MessageIn& msg);	virtual size_t printCurrentTo(Print& p) const=0;	virtual bool parseMessage(xPL_MessageIn& msg);	void trig();};class xPL_Sensor_Message : public xPL_Message {	enum {none, current,name} _request;public:	xPL_Sensor_Message(xPL_Sensor& sensor,const VString& request);	size_t printContentTo(Print& p) const;};class xPL_Sensor_MessageTrig : public xPL_Sensor_Message {public:	xPL_Sensor_MessageTrig(xPL_Sensor& sensor):xPL_Sensor_Message(sensor,S(current)) {};	const __FlashStringHelper* msgType() const { return S(trig); }};/********************************************************************Sensor Generic (float)********************************************************************/#include <float.h>class xPL_SensorBuffer {	float* _buffer;	byte _size;	byte _pos;public:	xPL_SensorBuffer():_buffer(NULL),_size(0),_pos(0) {  }	xPL_SensorBuffer(int size)	{		setSize(size);	}	~xPL_SensorBuffer() { free(_buffer); }	int size() { return _size; }	void setSize(int newSize) {		float* tmp = (float*)realloc(_buffer,sizeof(float)*newSize);		if (tmp)		{			_buffer = tmp;				for (int i=_size;i<newSize;i++) _buffer[i]=FLT_MAX;			// TODO : resize is a bit lasy, we should keep last values not truncate 			// but we won't need resize that mutch			_size=newSize;			if (_pos>=_size) _pos=0;		}	}	// will return true on buffer full	bool setValue(float v)	{		if (_pos>=_size) _pos=0;		_buffer[_pos++]=v;		if (_pos>=_size) return true;		return false;	}	float avg() {		double avg=0;		int count=0;		for (int i=0;i<_size;i++)		{			if (_buffer[i]!=FLT_MAX)			{				avg+=_buffer[i];				count++;			}		}		return avg/count;	}	float getMax()	{		double m=FLT_MIN;		for (int i=0;i<_size;i++)		{		if (_buffer[i]>m && _buffer[i]!=FLT_MAX)			 m = _buffer[i];		}		return m;	}};class xPL_SensorGeneric:public xPL_Sensor {protected:	mutable float _publicValue;	float _currentValue;	float  _highestValue;	float  _lowestValue;	float _threshold;	xPL_SensorBuffer _buffer;	mutable struct {		bool reset :1;	} _status;protected:	xPL_SensorGeneric(const VString& name=VString());	virtual const __FlashStringHelper* className() const { return S(generic); }	virtual const __FlashStringHelper* units() const { return F(""); }	virtual size_t printCurrentTo(Print& p) const;public:	void setValue(float v);	void setThreshold(float t) { _threshold=t; }	void setBuffer(int size) { _buffer.setSize(size); }};class xPL_SensorTemp:public xPL_SensorGeneric {
public:	virtual const __FlashStringHelper* className() const { return S(temp); }	virtual const __FlashStringHelper* units() const { return F("c"); }};class xPL_SensorHumidity:public xPL_SensorGeneric {
public:	virtual const __FlashStringHelper* className() const { return S(humidity); }	virtual const __FlashStringHelper* units() const { return F("%"); }};
class xPL_SensorPressure:public xPL_SensorGeneric {
public:	virtual const __FlashStringHelper* className() const { return S(pressure); }	virtual const __FlashStringHelper* units() const { return F("Pa"); }};class xPL_SensorDistance:public xPL_SensorGeneric {
public:	virtual const __FlashStringHelper* className() const { return S(distance); }	virtual const __FlashStringHelper* units() const { return F("m"); }};class xPL_SchemaSensor:public xPL_Schema {public:	virtual const __FlashStringHelper* className() const { return S(sensor); }	xPL_Sensor* add(xPL_Sensor* node) { return (xPL_Sensor*)addChild(node); }	virtual bool parseMessage(xPL_MessageIn& msg);};extern xPL_SchemaSensor xplSensor;#endif